$date
  Wed Nov 16 21:38:23 2022
$end
$version
  GHDL v0
$end
$timescale
  1 fs
$end
$scope module standard $end
$upscope $end
$scope module std_logic_1164 $end
$upscope $end
$scope module numeric_std $end
$upscope $end
$scope module adder_subtractor_tb $end
$var reg 12 ! x[11:0] $end
$var reg 12 " y[11:0] $end
$var reg 12 # s[11:0] $end
$var reg 1 $ mode $end
$var reg 1 % ov $end
$scope module uut $end
$var reg 12 & x[11:0] $end
$var reg 12 ' y[11:0] $end
$var reg 1 ( mode $end
$var reg 1 ) ov $end
$var reg 12 * s[11:0] $end
$var reg 12 + carry[11:0] $end
$var reg 12 , ym[11:0] $end
$scope module addsub(0) $end
$scope module bit0 $end
$scope module fa0 $end
$var reg 1 - a $end
$var reg 1 . b $end
$var reg 1 / cin $end
$var reg 1 0 cout $end
$var reg 1 1 s $end
$upscope $end
$upscope $end
$upscope $end
$scope module addsub(1) $end
$scope module bitx $end
$scope module fax $end
$var reg 1 2 a $end
$var reg 1 3 b $end
$var reg 1 4 cin $end
$var reg 1 5 cout $end
$var reg 1 6 s $end
$upscope $end
$upscope $end
$upscope $end
$scope module addsub(2) $end
$scope module bitx $end
$scope module fax $end
$var reg 1 7 a $end
$var reg 1 8 b $end
$var reg 1 9 cin $end
$var reg 1 : cout $end
$var reg 1 ; s $end
$upscope $end
$upscope $end
$upscope $end
$scope module addsub(3) $end
$scope module bitx $end
$scope module fax $end
$var reg 1 < a $end
$var reg 1 = b $end
$var reg 1 > cin $end
$var reg 1 ? cout $end
$var reg 1 @ s $end
$upscope $end
$upscope $end
$upscope $end
$scope module addsub(4) $end
$scope module bitx $end
$scope module fax $end
$var reg 1 A a $end
$var reg 1 B b $end
$var reg 1 C cin $end
$var reg 1 D cout $end
$var reg 1 E s $end
$upscope $end
$upscope $end
$upscope $end
$scope module addsub(5) $end
$scope module bitx $end
$scope module fax $end
$var reg 1 F a $end
$var reg 1 G b $end
$var reg 1 H cin $end
$var reg 1 I cout $end
$var reg 1 J s $end
$upscope $end
$upscope $end
$upscope $end
$scope module addsub(6) $end
$scope module bitx $end
$scope module fax $end
$var reg 1 K a $end
$var reg 1 L b $end
$var reg 1 M cin $end
$var reg 1 N cout $end
$var reg 1 O s $end
$upscope $end
$upscope $end
$upscope $end
$scope module addsub(7) $end
$scope module bitx $end
$scope module fax $end
$var reg 1 P a $end
$var reg 1 Q b $end
$var reg 1 R cin $end
$var reg 1 S cout $end
$var reg 1 T s $end
$upscope $end
$upscope $end
$upscope $end
$scope module addsub(8) $end
$scope module bitx $end
$scope module fax $end
$var reg 1 U a $end
$var reg 1 V b $end
$var reg 1 W cin $end
$var reg 1 X cout $end
$var reg 1 Y s $end
$upscope $end
$upscope $end
$upscope $end
$scope module addsub(9) $end
$scope module bitx $end
$scope module fax $end
$var reg 1 Z a $end
$var reg 1 [ b $end
$var reg 1 \ cin $end
$var reg 1 ] cout $end
$var reg 1 ^ s $end
$upscope $end
$upscope $end
$upscope $end
$scope module addsub(10) $end
$scope module bitx $end
$scope module fax $end
$var reg 1 _ a $end
$var reg 1 ` b $end
$var reg 1 a cin $end
$var reg 1 b cout $end
$var reg 1 c s $end
$upscope $end
$upscope $end
$upscope $end
$scope module addsub(11) $end
$scope module bitx $end
$scope module fax $end
$var reg 1 d a $end
$var reg 1 e b $end
$var reg 1 f cin $end
$var reg 1 g cout $end
$var reg 1 h s $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
b111100000000 !
b111100010001 "
b111000010001 #
0$
1%
b111100000000 &
b111100010001 '
0(
1)
b111000010001 *
b111100000000 +
b111100010001 ,
0-
1.
0/
00
11
02
03
04
05
06
07
08
09
0:
0;
0<
0=
0>
0?
0@
0A
1B
0C
0D
1E
0F
0G
0H
0I
0J
0K
0L
0M
0N
0O
0P
0Q
0R
0S
0T
1U
1V
0W
1X
0Y
1Z
1[
1\
1]
1^
1_
1`
1a
1b
1c
1d
1e
1f
1g
1h
#10000000
b100011110000 !
b100111110000 "
b111100000000 #
1$
0%
b100011110000 &
b100111110000 '
1(
0)
b111100000000 *
b000011111111 +
b011000001111 ,
1/
10
01
13
14
15
18
19
1:
0;
1=
1>
1?
0@
1A
0B
1C
1D
0E
1F
1H
1I
0J
1K
1M
1N
0O
1P
1R
1S
0T
0U
0V
1W
0X
1Y
0Z
0\
0]
1^
0_
0a
0b
1c
0e
0f
0g
1h
#20000000
